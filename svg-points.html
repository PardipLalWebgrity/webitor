<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
  </head>
  <body>

    <style>
  *{padding: 0;margin: 0;box-sizing: border-box;}
  body{width: 100%;height: 100vh;display: flex;justify-content: center;align-items: center;padding: 200px;}
  svg{width: 600px; height: 400px; border:1px solid #ddd;}
 
 </style>

    
      <svg id="svg" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 640">
        <path id="pathPoints"
          d="M566.6 342.6C579.1 330.1 579.1 309.8 566.6 297.3L406.6 137.3C394.1 124.8 373.8 124.8 361.3 137.3C348.8 149.8 348.8 170.1 361.3 182.6L466.7 288L96 288C78.3 288 64 302.3 64 320C64 337.7 78.3 352 96 352L466.7 352L361.3 457.4C348.8 469.9 348.8 490.2 361.3 502.7C373.8 515.2 394.1 515.2 406.6 502.7L566.6 342.7z" />    
        <path id="circlesPath" fill="red" stroke="transparent" stroke-width="0" />      
      </svg>

    <script>

      /********************* Utility Functions **************************/
      
      function getCirclesPathD(points, r = 6, attrs = {}) {
        if (!Array.isArray(points) || points.length === 0) {
          throw new Error('points must be a non-empty array of {x,y} objects');
        }

        // Build 'd' by joining subpaths for each point.
        const d = points.map(p => {
          const cx = Number(p.x);
          const cy = Number(p.y);
          // Move to center, then relative move left by r, then two arcs completing a circle.
          return `M ${cx} ${cy} m -${r} 0 a ${r} ${r} 0 1 0 ${2*r} 0 a ${r} ${r} 0 1 0 -${2*r} 0`;
        }).join(' ');

        return d;
      }

      function getClickedPointIndexFromEvent(event, svg, points, radius = 8) {
        // Convert mouse coordinates to SVG space
        const pt = svg.createSVGPoint();
        pt.x = event.clientX;
        pt.y = event.clientY;
        const svgP = pt.matrixTransform(svg.getScreenCTM().inverse());
        const { x, y } = svgP;

        // Loop through points to find which one was clicked
        for (let i = 0; i < points.length; i++) {
          const dx = points[i].x - x;
          const dy = points[i].y - y;
          const dist = Math.sqrt(dx * dx + dy * dy);
          if (dist <= radius) return i; // clicked inside circle
        }
        return -1; // no match
      }

      /********************* Utility Functions **************************/







      /********************* Points Render **************************/

      // Reference Elements
      const svgEl = document.querySelector('#svg');
      const pathPoints = document.querySelector('#pathPoints');
      const circlesPath = document.querySelector('#circlesPath');
      const pathData = pathPoints.getPathData();
      const points = [];

      // Calculate Points
      pathData.forEach((pd)=>{
        points.push(...pd.values);        
      });

      // XY Points Array
      const xyPoints = [];
      for (let i = 0; i < points.length; i += 2) {
        xyPoints.push({ x: points[i], y: points[i + 1] });
      }
      
      // UI Rendering
      const pathCirclesD = getCirclesPathD(xyPoints, 8, { fill: '#f88', stroke: '#b00', 'stroke-width': 1 });
      circlesPath.setAttribute('d', pathCirclesD);
      

      /********************* Points Render **************************/
      






      /********************* Points Control **************************/

      let activeIndex = -1;

      // Pointer Down Event
      svgEl.addEventListener('pointerdown', (e)=>{
        const rect = svgEl.getBoundingClientRect();        
        activeIndex = getClickedPointIndexFromEvent(e, svgEl, xyPoints, 8);
        if(activeIndex !== -1){
          console.log('Clicked Point Index:', activeIndex);
        } else {
          console.log('No point clicked');
        }
      });

      // Pointer Move Event
      svgEl.addEventListener('pointermove', (e)=>{
        let rect = svgEl.getBoundingClientRect();
        if(activeIndex !== -1){
          const pt = svgEl.createSVGPoint();
          pt.x = e.clientX;
          pt.y = e.clientY;
          const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
          const { x, y } = svgP;

          // Update point position
          xyPoints[activeIndex] = { x, y };

          // Re-render circles path
          const updatedD = getCirclesPathD(xyPoints, 8, { fill: '#f88', stroke: '#b00', 'stroke-width': 1 });
          circlesPath.setAttribute('d', updatedD);
        }
      });

      // Pointer Up Event
      svgEl.addEventListener('pointerup', (e)=>{
        activeIndex = -1; // Reset active index
      });
      
      /********************* Points Control **************************/
      
  </script>

  </body>
</html>
